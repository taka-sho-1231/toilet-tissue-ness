name: Auto Tag on Merge

on:
  pull_request:
    types: [closed]
    branches:
      - master  # ðŸ’¡ Only target merges to the master branch (remove if not needed)

# Permission settings: contents: write is required to push tags
permissions:
  contents: write
  pull-requests: read # Required to read PR label information

jobs:
  tag:
    # Only execute when PR is merged to the master branch
    # ðŸ’¡ If not using `on.pull_request.branches`, remove `github.event.pull_request.base.ref == 'master'`
    if: github.event.pull_request.base.ref == 'master' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    # ðŸ’¡ Prevent concurrent execution of tagging jobs in case of simultaneous merges
    concurrency:
      group: ${{ github.repository }}-tagging
      cancel-in-progress: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # ðŸ’¡ Fetch all history so git describe can find past tags correctly
          fetch-depth: 0

      - name: Get latest stable tag
        id: get_tag
        run: |
          git fetch --tags
          # ðŸ’¡ Target only stable tags in vX.Y.Z format, use v0.0.0 if none exist
          latest_tag=$(git describe --tags --abbrev=0 --match "v[0-9]*.[0-9]*.[0-9]*" 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT
          echo "Found latest tag: $latest_tag"

      - name: Determine next version
        id: bump
        run: |
          # Extract PR labels from JSON
          label_names=$(jq -r '.pull_request.labels[].name' <<< '${{ toJson(github.event) }}')
          
          version="${{ steps.get_tag.outputs.latest_tag }}"
          version="${version#v}" # Remove "v" prefix
          
          IFS='.' read -r major minor patch <<< "$version"

          # ðŸ’¡ Increment version based on PR labels
          if echo "$label_names" | grep -qi "major"; then # -i for case-insensitive matching
            major=$((major+1)); minor=0; patch=0
            echo "Bumping major version"
          elif echo "$label_names" | grep -qi "minor"; then
            minor=$((minor+1)); patch=0
            echo "Bumping minor version"
          elif echo "$label_names" | grep -qi "patch"; then
            patch=$((patch+1))
            echo "Bumping patch version"
          else
            echo "No version label (major, minor, patch) found. Skipping."
            echo "new_tag=" >> $GITHUB_OUTPUT # Set new_tag to empty
            exit 0 # Exit job as successful
          fi

          new_tag="v${major}.${minor}.${patch}"
          echo "New tag: $new_tag"
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

      # ðŸ’¡ Configure bot information for pushing tags
      - name: Configure Git
        if: steps.bump.outputs.new_tag != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create and push new tag
        if: steps.bump.outputs.new_tag != '' # Execute only when new_tag is set
        run: |
          new_tag="${{ steps.bump.outputs.new_tag }}"
          # ðŸ’¡ Tag the merge commit (github.sha)
          echo "Creating and pushing tag: $new_tag"
          git tag "$new_tag" ${{ github.sha }}
          git push origin "$new_tag"